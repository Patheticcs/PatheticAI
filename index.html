<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>PatheticAI Enhanced</title>

<link rel="manifest" href="/manifest.json">

<link href="https://api.fontshare.com/v2/css?f[]=cabinet-grotesk@700,400&display=swap" rel="stylesheet">
<style>
  body {
    font-family: 'Cabinet Grotesk', sans-serif;
  }
</style>

<link rel="icon" href="/images/icon.png" type="image/png">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js"></script>

<link rel="preload" href="/index.css" as="style">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github-dark.min.css" as="style">
	  
<meta name="description" content="PatheticAI - Advanced AI chatbot with enhanced features for seamless conversations and task automation">
<meta name="keywords" content="AI, chatbot, machine learning, conversation, automation">
<meta name="robots" content="index, follow">
<meta property="og:title" content="PatheticAI Enhanced">
<meta property="og:description" content="Advanced AI chatbot with enhanced features for seamless conversations and task automation">
<meta property="og:image" content="/images/icon.png">
<meta property="og:type" content="website">
<meta property="og:site_name" content="PatheticAI">
<meta name="theme-color" content="#ffffff">

<link rel="apple-touch-icon" href="/images/icon.png">
<meta name="apple-mobile-web-app-title" content="PatheticAI">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">

<link rel="stylesheet" href="/index.css">
  </head>
  <body>
    <div class="taskbar">
      <div class="taskbar-left">
        <span class="brand">PatheticAI</span>
        <span class="preview-tag">Enhanced Edition</span>
      </div>
      <div class="taskbar-right">
        <button onclick="showSettingsModal()" title="Settings">
          <i class="fas fa-cog"></i>
        </button>
        <button onclick="showAboutModal()" title="Join Discord">
          <i class="fa fa-user-group"></i>
        </button>
        <button onclick="contactEmail()" title="Join Discord">
          <i class="fa-brands fa-discord"></i>
        </button>
      </div>
    </div>
    <div class="container">
      <div class="chat-messages"></div>
    </div>
    <div class="chat-input-container">
      <textarea id="messageInput" placeholder="Type your message..." rows="1" maxlength="2000"></textarea>
      <button onclick="sendMessage()" title="Send Message">
        <i class="fas fa-paper-plane"></i>
        <span>â€Ž â€Ž â€Ž Send</span>
      </button>
    </div>
    <script>
    const CONFIG = {
      MAX_RETRIES: 3,
      TYPING_SPEED: 50,
      MAX_CONTEXT_LENGTH: 10,
      SUGGESTION_COUNT: 4,
      API_TIMEOUT: 30000,
      STORAGE_KEYS: {
        THEME: 'theme',
        API_KEY: 'openRouterApiKey',
        MESSAGES: 'chatMessages',
        LANGUAGE: 'preferredLanguage',
        SETTINGS: 'userSettings'
      }
    };

    const MODELS = [{
      name: "google/gemini-2.0-flash-exp:free"
    }, {
      name: "meta-llama/llama-3.2-3b-instruct:free"
    }, {
      name: "qwen/qwen-2-7b-instruct:free"
    }, {
      name: "microsoft/phi-3-medium-128k-instruct:free"
    }, {
      name: "undi95/toppy-m-7b:free"
    }, {
      name: "google/gemini-2.0-flash-thinking-exp:free"
    }, {
      name: "microsoft/phi-3-mini-128k-instruct:free"
    }]; 

    let STATE = {
      isWaitingForResponse: false,
      editingMessageId: null,
      voiceRecording: false,
      messageHistory: [],
      currentLanguage: 'English',
      theme: 'dark',
      selectedModel: MODELS[0].name,
      contextLength: 0,
      mediaRecorder: null,
      settings: {
        notifications: true,
        soundEffects: true,
        autoScroll: true
      }
    };

    const systemMessage = {
      role: "system",
      content: `You are PatheticAI Enhanced

        Key characteristics:
        - Friendly and empathetic AI assistant
        - Provides clear, concise responses
        - Adapts communication style to user needs
        - Offers helpful suggestions and insights
        - Maintains context awareness`
    };

    document.addEventListener('DOMContentLoaded', () => {
      initializeApp();
    });

    function initializeApp() {
      loadSavedState();
      initializeUI();
      initializePersonality();
      setupEventListeners();
      showWelcomeMessage();
      if (!checkAndStoreApiKey()) {
        disableInput();
      }
      initializeVoiceInput();
    }

    async function toggleVoiceInput() {
      const voiceButton = document.querySelector('.voice-input-button');
      const messageInput = document.getElementById('messageInput');
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (!STATE.voiceRecording) {
        if (!SpeechRecognition) {
          showError('Your browser does not support the Web Speech API');
          return;
        }

        try {
          const recognition = new SpeechRecognition();
          recognition.continuous = false; 
          recognition.interimResults = true; 
          recognition.lang = 'en-US'; 

          STATE.recognition = recognition;

          recognition.onstart = () => {
            STATE.voiceRecording = true;
            voiceButton.classList.add('recording');
            showNotification('Voice recording started');
          };

          recognition.onresult = (event) => {
            let transcript = '';
            let interimTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
              const result = event.results[i];
              if (result.isFinal) {
                transcript += result[0].transcript; 
              } else {
                interimTranscript += result[0].transcript; 
              }
            }

            messageInput.value = transcript || interimTranscript;

            messageInput.focus();
          };

          recognition.onerror = (event) => {
            showError('Speech recognition error');
            console.error('Speech recognition error:', event.error);
          };

          recognition.onend = () => {
            STATE.voiceRecording = false;
            voiceButton.classList.remove('recording');
            showNotification('Voice recording stopped');
          };

          recognition.start();
        } catch (error) {
          showError('Microphone access denied');
          voiceButton.disabled = true;
        }
      } else {
        if (STATE.recognition) {
          STATE.recognition.stop();
          STATE.voiceRecording = false;
          voiceButton.classList.remove('recording');
          showNotification('Voice recording stopped');
        }
      }
    }

    function loadSavedState() {
      try {
        const savedMessages = localStorage.getItem(CONFIG.STORAGE_KEYS.MESSAGES);
        if (savedMessages) {
          STATE.messageHistory = JSON.parse(savedMessages);
          STATE.messageHistory = STATE.messageHistory.filter(msg => msg && msg.role && msg.content && msg.timestamp);
          const chatMessages = document.querySelector('.chat-messages');
          chatMessages.innerHTML = '';
          STATE.messageHistory.forEach(msg => {
            const isUser = msg.role === 'user';
            const {
              element
            } = createMessageElement(msg.content, isUser, new Date(msg.timestamp));
            chatMessages.appendChild(element);
          });
        } else {
          showWelcomeMessage();
        }
        const savedSettings = localStorage.getItem(CONFIG.STORAGE_KEYS.SETTINGS);
        if (savedSettings) {
          const parsedSettings = JSON.parse(savedSettings);
          STATE.settings = {
            ...STATE.settings,
            ...parsedSettings
          };
        }
        const savedTheme = localStorage.getItem(CONFIG.STORAGE_KEYS.THEME);
        if (savedTheme) {
          STATE.theme = savedTheme;
          document.documentElement.setAttribute('data-theme', savedTheme);
        }
        const savedLanguage = localStorage.getItem(CONFIG.STORAGE_KEYS.LANGUAGE);
        if (savedLanguage) {
          STATE.currentLanguage = savedLanguage;
        }
      } catch (error) {
        console.error('Error loading saved state:', error);
        STATE.messageHistory = [];
        saveToLocalStorage(CONFIG.STORAGE_KEYS.MESSAGES, []);
        showWelcomeMessage();
      }
    }

    function saveToLocalStorage(key, value) {
      try {
        const serializedValue = typeof value === 'string' ? value : JSON.stringify(value);
        localStorage.setItem(key, serializedValue);
        const savedValue = localStorage.getItem(key);
        if (!savedValue) {
          throw new Error('Verification failed: Saved value is null');
        }
        return true;
      } catch (error) {
        console.error('Local storage error:', error);
        if (error.name === 'QuotaExceededError') {
          showNotification('Storage limit reached. Some messages may not be saved.');
          if (key === CONFIG.STORAGE_KEYS.MESSAGES && Array.isArray(value)) {
            const recentMessages = value.slice(-50);
            try {
              localStorage.setItem(key, JSON.stringify(recentMessages));
              return true;
            } catch (e) {
              console.error('Failed to save recent messages:', e);
            }
          }
        }
        return false;
      }
    }

    function formatTimestamp(date) {
      return new Intl.DateTimeFormat('default', {
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      }).format(date);
    }
    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        showNotification('Copied to clipboard');
      } catch (err) {
        showNotification('Failed to copy to clipboard');
      }
    }

    function createMessageElement(message, isUser, timestamp = new Date()) {
      const messageId = Date.now().toString();
      const messageElement = document.createElement('div');
      messageElement.classList.add('chat-message', isUser ? 'user' : 'bot');
      messageElement.dataset.messageId = messageId;
      const contentDiv = document.createElement('div');
      contentDiv.classList.add('message-content');
      if (!isUser) {
        contentDiv.innerHTML = marked.parse(message);
        contentDiv.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      } else {
        contentDiv.textContent = message;
      }
      messageElement.appendChild(contentDiv);
      const timestampDiv = document.createElement('div');
      timestampDiv.className = 'message-timestamp';
      timestampDiv.textContent = formatTimestamp(timestamp);
      messageElement.appendChild(timestampDiv);
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'message-actions';
      if (isUser) {
        const editButton = document.createElement('button');
        editButton.className = 'action-button';
        editButton.innerHTML = '  <i class = "fas fa-edit" ></i>';
        editButton.onclick = () => startEditing(messageId);
        actionsDiv.appendChild(editButton);
      }
      const copyButton = document.createElement('button');
      copyButton.className = 'action-button';
      copyButton.innerHTML = '  <i class = "fas fa-copy" ></i>';
      copyButton.onclick = () => copyToClipboard(message);
      actionsDiv.appendChild(copyButton);
      messageElement.appendChild(actionsDiv);
      return {
        element: messageElement,
        id: messageId
      };
    }
    const PERSONALITIES = {
      Professional: {
        description: "Clear, helpful, and business-like responses",
        systemPrompt: "You are a professional AI assistant. Provide clear, concise, and formal responses."
      },
      Casual: {
        description: "Friendly and relaxed conversation style",
        systemPrompt: "You are a casual and friendly AI assistant. Use informal language and be conversational."
      },
      Poetic: {
        description: "Artistic and metaphorical communication",
        systemPrompt: "You are a poetic AI assistant. Express ideas with artistic flair and metaphorical language."
      },
      Rude: {
        description: "Sarcastic and slightly impatient",
        systemPrompt: "You are a sarcastic AI assistant. Be blunt and slightly impatient, but still helpful."
      },
      Witty: {
        description: "Clever and humorous responses",
        systemPrompt: "You are a witty AI assistant. Use wordplay and clever humor in your responses."
      },
      Academic: {
        description: "Scholarly and detailed explanations",
        systemPrompt: "You are an academic AI assistant. Provide detailed, well-structured responses with scholarly tone."
      },
      Enthusiastic: {
        description: "High-energy and encouraging",
        systemPrompt: "You are an enthusiastic AI assistant. Be energetic, positive, and encouraging in all responses."
      },
      Zen: {
        description: "Calm and mindful communication",
        systemPrompt: "You are a zen-like AI assistant. Provide peaceful, mindful responses with wisdom and tranquility."
      }
    };
    async function startEditing(messageId) {
      if (STATE.isWaitingForResponse) return;
      const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
      if (!messageElement) return;
      const contentDiv = messageElement.querySelector('.message-content');
      const originalText = contentDiv.textContent;
      const textarea = document.createElement('textarea');
      textarea.className = 'edit-input';
      textarea.value = originalText;
      contentDiv.replaceWith(textarea);
      textarea.focus();
      messageElement.classList.add('edit-mode');
      STATE.editingMessageId = messageId;
      const handleEdit = async (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          await finishEditing(messageId, textarea.value.trim());
        } else if (e.key === 'Escape') {
          finishEditing(messageId, originalText);
        }
      };
      textarea.addEventListener('keydown', handleEdit);
    }
    async function finishEditing(messageId, newText) {
      if (!messageId || !newText || STATE.isWaitingForResponse) return;
      const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
      if (!messageElement) return;
      const textarea = messageElement.querySelector('.edit-input');
      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.textContent = newText;
      textarea.replaceWith(contentDiv);
      messageElement.classList.remove('edit-mode');
      const messageIndex = STATE.messageHistory.findIndex(msg => msg.id === messageId);
      if (messageIndex === -1) return;
      STATE.messageHistory[messageIndex].content = newText;
      const nextIndex = messageIndex + 1;
      if (nextIndex < STATE.messageHistory.length && STATE.messageHistory[nextIndex].role === 'assistant') {
        STATE.messageHistory.splice(nextIndex, 1);
        const nextElement = messageElement.nextElementSibling;
        if (nextElement) nextElement.remove();
      }
      try {
        STATE.isWaitingForResponse = true;
        const response = await sendMessageWithRetry(newText);
        if (response.text) {
          const botMessageObj = {
            role: "assistant",
            content: response.text,
            timestamp: Date.now(),
            replyTo: messageId
          };
          STATE.messageHistory.splice(nextIndex, 0, botMessageObj);
          const {
            element: botElement
          } = createMessageElement(response.text, false);
          messageElement.after(botElement);
          if (STATE.settings.autoScroll) {
            botElement.scrollIntoView({
              behavior: 'smooth'
            });
          }
          if (STATE.settings.soundEffects) {
            playMessageSound();
          }
        }
      } catch (error) {
        showError(`Error updating response: ${error.message}`);
      } finally {
        STATE.isWaitingForResponse = false;
        STATE.editingMessageId = null;
      }
      saveToLocalStorage(CONFIG.STORAGE_KEYS.MESSAGES, STATE.messageHistory);
    }
    document.getElementById('messageInput').addEventListener('keydown', function(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    });

    function changePersonality(personality) {
      STATE.personality = personality;
      systemMessage.content = PERSONALITIES[personality].systemPrompt;
      const descriptionElement = document.querySelector('.personality-description');
      if (descriptionElement) {
        descriptionElement.textContent = PERSONALITIES[personality].description;
      }
      saveToLocalStorage('chatPersonality', personality);
      showNotification(`Personality changed to ${personality}`);
    }

    function initializePersonality() {
      const savedPersonality = localStorage.getItem('chatPersonality');
      if (savedPersonality && PERSONALITIES[savedPersonality]) {
        STATE.personality = savedPersonality;
        systemMessage.content = PERSONALITIES[savedPersonality].systemPrompt;
      }
    }
    async function sendMessage() {
      const textarea = document.getElementById('messageInput');
      const message = textarea.value.trim();
      if (!message || STATE.isWaitingForResponse || STATE.editingMessageId) return;
      STATE.isWaitingForResponse = true;
      disableInput();
      const timestamp = new Date();
      const {
        element: messageElement,
        id: messageId
      } = createMessageElement(message, true, timestamp);
      document.querySelector('.chat-messages').appendChild(messageElement);
      const messageObj = {
        role: "user",
        content: message,
        timestamp: timestamp.getTime(),
        id: messageId
      };
      STATE.messageHistory.push(messageObj);
      saveToLocalStorage(CONFIG.STORAGE_KEYS.MESSAGES, STATE.messageHistory);
      textarea.value = '';
      textarea.style.height = 'auto';
      try {
        const response = await sendMessageWithRetry(message);
        if (response.text) {
          const botMessageObj = {
            role: "assistant",
            content: response.text,
            timestamp: Date.now(),
            replyTo: messageId
          };
          STATE.messageHistory.push(botMessageObj);
          saveToLocalStorage(CONFIG.STORAGE_KEYS.MESSAGES, STATE.messageHistory);
          const {
            element: botElement
          } = createMessageElement(response.text, false);
          document.querySelector('.chat-messages').appendChild(botElement);
          if (STATE.settings.autoScroll) {
            botElement.scrollIntoView({
              behavior: 'smooth'
            });
          }
          if (STATE.settings.soundEffects) {
            playMessageSound();
          }
        }
      } catch (error) {
        showError(`Error: ${error.message}`);
      } finally {
        STATE.isWaitingForResponse = false;
        enableInput();
        textarea.focus();
      }
    }
    async function sendMessageWithRetry(message, retries = CONFIG.MAX_RETRIES) {
      try {
        const response = await tryMultipleModels(message);
        return response;
      } catch (error) {
        if (retries > 0) {
          showNotification(`Retrying... (${retries} attempts left)`);
          await new Promise(resolve => setTimeout(resolve, 1000));
          return sendMessageWithRetry(message, retries - 1);
        }
        throw error;
      }
    }
    async function tryMultipleModels(userMessage) {
      const apiKey = getApiKey();
      if (!apiKey) {
        throw new Error("API key not found. Please enter your API key first.");
      }
      for (let modelIndex = 0; modelIndex < MODELS.length; modelIndex++) {
        try {
          const response = await Promise.race([
            fetch("https://openrouter.ai/api/v1/chat/completions", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                "model": MODELS[modelIndex].name,
                "messages": [
                  systemMessage, ...STATE.messageHistory.filter(msg => msg.role === "user" || msg.role === "assistant"), {
                    role: "user",
                    content: `Please respond in ${STATE.currentLanguage}. ${userMessage}`
                  }
                ]
              })
            }).then(async res => {
              if (!res.ok) {
                const errorData = await res.json();
                throw new Error(`API Error: ${errorData.error?.message || 'Unknown error'}`);
              }
              return res.json();
            }),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Request timeout')), CONFIG.API_TIMEOUT))
          ]);
          if (response.choices && response.choices[0].message.content) {
            return {
              text: response.choices[0].message.content
            };
          }
        } catch (error) {
          console.error(`Model ${MODELS[modelIndex].name} failed:`, error);
          if (modelIndex === MODELS.length - 1) {
            throw new Error(`API Error: ${error.message}`);
          }
          continue;
        }
      }
      throw new Error("All API attempts failed. Please try again later.");
    }
    async function toggleVoiceInput() {
      const voiceButton = document.querySelector('.voice-input-button');
      const messageInput = document.getElementById('messageInput');
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (!STATE.voiceRecording) {
        if (!SpeechRecognition) {
          showError('Your browser does not support the Web Speech API');
          return;
        }

        try {
          const recognition = new SpeechRecognition();
          recognition.continuous = false; 
          recognition.interimResults = true; 
          recognition.lang = 'en-US'; 

          STATE.recognition = recognition;

          recognition.onstart = () => {
            STATE.voiceRecording = true;
            voiceButton.classList.add('recording');
            showNotification('Voice recording started');
          };

          recognition.onresult = (event) => {
            let transcript = '';
            let interimTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
              const result = event.results[i];
              if (result.isFinal) {
                transcript += result[0].transcript; 
              } else {
                interimTranscript += result[0].transcript; 
              }
            }

            messageInput.value = transcript || interimTranscript;
            messageInput.focus(); 
          };

          recognition.onerror = (event) => {
            showError('Speech recognition error');
            console.error('Speech recognition error:', event.error);
          };

          recognition.onend = () => {
            STATE.voiceRecording = false;
            voiceButton.classList.remove('recording');
            showNotification('Voice recording stopped');
          };

          recognition.start();
        } catch (error) {
          showError('Microphone access denied');
          voiceButton.disabled = true;
        }
      } else {
        if (STATE.recognition) {
          STATE.recognition.stop();
          STATE.voiceRecording = false;
          voiceButton.classList.remove('recording');
          showNotification('Voice recording stopped');
        }
      }
    }

    function initializeVoiceInput() {
      const chatInput = document.querySelector('.chat-input-container');
      if (chatInput) {
        const voiceButton = document.createElement('button');
        voiceButton.className = 'voice-input-button';
        voiceButton.innerHTML = '<i class="fas fa-microphone"></i> Start Voice Input';
        voiceButton.title = 'Voice Input';
        voiceButton.onclick = toggleVoiceInput;
        chatInput.insertBefore(voiceButton, chatInput.lastElementChild);
      }
    }

    function setupEventListeners() {
      window.addEventListener('focus', handleWindowFocus);
      window.addEventListener('blur', handleWindowBlur);
      window.addEventListener('online', () => showNotification('You are back online!'));
      window.addEventListener('offline', () => showNotification('You are offline. Some features may be unavailable.'));
      window.addEventListener('beforeunload', handleBeforeUnload);
      document.querySelector('.container').addEventListener('wheel', handleScroll);
      document.querySelector('.brand').addEventListener('click', showAboutModal);
      window.addEventListener('resize', handleResize);
    }

    function handleWindowFocus() {
      if (STATE.settings.notifications) {
        document.title = 'PatheticAI Enhanced';
      }
    }

    function handleWindowBlur() {
      if (STATE.settings.notifications) {
        const unreadMessages = STATE.messageHistory.filter(msg => msg.role === 'assistant' && msg.timestamp > document.lastModified).length;
        if (unreadMessages > 0) {
          document.title = `(${unreadMessages}) PatheticAI Enhanced`;
        }
      }
    }

    function handleBeforeUnload(e) {
      if (STATE.isWaitingForResponse || STATE.editingMessageId) {
        e.preventDefault();
        e.returnValue = '';
      }
    }

    function handleScroll(e) {
      if (STATE.settings.autoScroll) {
        const container = document.querySelector('.container');
        const isScrolledToBottom = container.scrollHeight - container.clientHeight <= container.scrollTop + 1;
        if (!isScrolledToBottom) {
          STATE.settings.autoScroll = false;
          showNotification('Auto-scroll disabled');
          saveToLocalStorage(CONFIG.STORAGE_KEYS.SETTINGS, STATE.settings);
        }
      }
    }

    function handleResize() {
      const textarea = document.getElementById('messageInput');
      if (textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
      }
    }

    function showSettingsModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      const personalityOptions = Object.keys(PERSONALITIES).map(p => `

																	<div class="option" data-personality="${p}" onclick="changePersonality('${p}')">${p}</div>
          `).join('');
      const languageOptions = ['English', 'Spanish', 'French', 'German', 'Italian', 'Japanese', 'Chinese', 'Russian', 'Portuguese', 'Korean', 'Hindi', 'Arabic'].map(lang => `

																	<div class="option" data-language="${lang}" onclick="changeLanguage('${lang}')">${lang}</div>
            `).join('');
      const themeOptions = `

																	<div class="option" data-theme="light" onclick="changeTheme('light')">Light</div>
																	<div class="option" data-theme="dark" onclick="changeTheme('dark')">Dark</div>
          `;
      modal.innerHTML = `

																	<div class="modal-window">
																		<div class="modal-header">
																			<span class="modal-title">Settings</span>
																			<button class="close-button" aria-label="Close settings" onclick="closeModal()">âœ–</button>
																		</div>
																		<div class="modal-content">
																			<div class="settings-section">
																				<div class="settings-button" onclick="resetChat()">
																					<i class="fa fa-trash"></i> Clear Chat

																				</div>
																			</div>
																			<div class="settings-section">
																				<div class="selector-container">
																					<div class="selector" id="personalitySelector" onclick="togglePersonalitySelector()">
																						<span>Personality: ${PERSONALITIES[STATE.personality]?.name || 'Select Personality'}</span>
																						<i class="fa fa-chevron-down"></i>
																					</div>
																					<div class="options" id="personalityOptions" style="display:none;">
                      ${personalityOptions}
                    </div>
																					<div id="personalityDescription" class="option-description">
                      ${PERSONALITIES[STATE.personality]?.description || 'Select a personality to view the description.'}
                    </div>
																				</div>
																			</div>
																			<div class="settings-section">
																				<div class="selector-container">
																					<div class="selector" id="languageSelector" onclick="toggleLanguageSelector()">
																						<span>Language: ${STATE.currentLanguage}</span>
																						<i class="fa fa-chevron-down"></i>
																					</div>
																					<div class="options" id="languageOptions" style="display:none;">
                      ${languageOptions}
                    </div>
																				</div>
																			</div>
																			<div class="settings-section">
																				<div class="settings-button" onclick="toggleSetting('notifications')">
																					<i class="fas fa-bell"></i> Notifications: ${STATE.settings.notifications ? 'On' : 'Off'}

																				</div>
																				<div class="settings-button" onclick="toggleSetting('soundEffects')">
																					<i class="fas fa-volume-up"></i> Sound Effects: ${STATE.settings.soundEffects ? 'On' : 'Off'}

																				</div>
																				<div class="settings-button" onclick="toggleSetting('autoScroll')">
																					<i class="fas fa-scroll"></i> Auto Scroll: ${STATE.settings.autoScroll ? 'On' : 'Off'}

																				</div>
																				<div class="settings-button" onclick="removeApiKey()">
																					<i class="fas fa-key"></i> Remove API Key

																				</div>
																			</div>
																			<div class="settings-section">
																				<div class="selector-container">
																					<div class="selector" id="themeSelector" onclick="toggleThemeSelector()">
																						<span>Select Theme</span>
																						<i class="fa fa-chevron-down"></i>
																					</div>
																					<div class="options" id="themeOptions">
                      ${themeOptions}
                    </div>
																				</div>
																			</div>
																		</div>
																	</div>
          `;
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });
      document.body.appendChild(modal);
    }

    function closeModal() {
      document.querySelector('.modal-overlay').remove();
    }

    function togglePersonalitySelector() {
      const options = document.getElementById('personalityOptions');
      options.style.display = options.style.display === 'none' || options.style.display === '' ? 'block' : 'none';
    }

    function toggleLanguageSelector() {
      const options = document.getElementById('languageOptions');
      options.style.display = options.style.display === 'none' || options.style.display === '' ? 'block' : 'none';
    }

    function toggleThemeSelector() {
      const themeOptions = document.getElementById('themeOptions');
      themeOptions.style.display = themeOptions.style.display === 'none' || themeOptions.style.display === '' ? 'block' : 'none';
    }

    function changePersonality(personality) {
      STATE.personality = personality;
      const personalityDescription = document.getElementById('personalityDescription');
      const personalitySelector = document.getElementById('personalitySelector').querySelector('span');
      personalityDescription.textContent = PERSONALITIES[personality]?.description || 'Select a personality to view the description.';
      personalitySelector.textContent = `Personality: ${PERSONALITIES[personality]?.name || 'Select Personality'}`;
      saveToLocalStorage(CONFIG.STORAGE_KEYS.PERSONALITY, personality);
      showNotification(`Personality changed to ${PERSONALITIES[personality]?.name || 'unknown'}`);
    }

    function changeLanguage(language) {
      STATE.currentLanguage = language;
      const languageSelector = document.getElementById('languageSelector').querySelector('span');
      languageSelector.textContent = `Language: ${language}`;
      showNotification(`Language changed to ${language}`);
    }

    function changeTheme(theme) {
      STATE.theme = theme;
      document.documentElement.setAttribute('data-theme', theme);
      saveToLocalStorage(CONFIG.STORAGE_KEYS.THEME, theme);
      const themeSelector = document.getElementById('themeSelector').querySelector('span');
      themeSelector.textContent = `Theme: ${theme}`;
      document.getElementById('themeOptions').style.display = 'none';
      showNotification(`Theme changed to ${theme}`);
    }

    function toggleSetting(setting) {
      STATE.settings[setting] = !STATE.settings[setting];
      saveToLocalStorage(CONFIG.STORAGE_KEYS.SETTINGS, STATE.settings);
      const settingButton = document.querySelector(`[onclick="toggleSetting('${setting}')"]`);
      if (settingButton) {
        settingButton.textContent = `${setting.charAt(0).toUpperCase() + setting.slice(1)}: ${STATE.settings[setting] ? 'On' : 'Off'}`;
      }
      showNotification(`${setting} ${STATE.settings[setting] ? 'enabled' : 'disabled'}`);
      closeModal();
      showSettingsModal();
    }

    function resetChat() {
      STATE.messageHistory = [];
      saveToLocalStorage(CONFIG.STORAGE_KEYS.MESSAGES, []);
      document.querySelector('.chat-messages').innerHTML = '';
      showNotification('Chat history cleared');
      showWelcomeMessage();
    }

    function showWelcomeMessage() {
      const welcomeMessage = "ðŸ‘‹ Welcome to PatheticAI Enhanced! I'm here to help you with any questions or tasks you may have. Feel free to start our conversation!";
      const {
        element
      } = createMessageElement(welcomeMessage, false);
      document.querySelector('.chat-messages').appendChild(element);
    }

    function playMessageSound() {
      if (!STATE.settings.soundEffects) return;
      const audio = new Audio('audios/notification.mp3');
      audio.volume = 0.5;
      audio.play().catch(err => console.log('Error playing sound', err));
    }

    function initializeTheme() {
      const savedTheme = localStorage.getItem(CONFIG.STORAGE_KEYS.THEME) || 'light';
      document.documentElement.setAttribute('data-theme', savedTheme);
      STATE.theme = savedTheme;
    }

    function showAboutModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `

																	<div class="modal-window">
																		<div class="modal-header">
																			<span class="modal-title">About PatheticAI</span>
																			<button class="close-button" onclick="this.closest('.modal-overlay').remove()">âœ–</button>
																		</div>
																		<div class="modal-content">
																			<p>
																				<strong>PatheticAI:</strong> 1.0 Enhanced

																			</p>
																			<p>
																				<strong>API version:</strong> 1.0

																			</p>
																			<p>
																				<strong>Contact:</strong>
																				<a href="discord.gg/Hb5ccPY3XV">discord.gg/Hb5ccPY3XVm</a>
																			</p>
																			<br>
																				<p>
																					<strong>Enhanced Features:</strong>
																				</p>
																				<ul>
																					<li>Improved message handling</li>
																					<li>Better code display and copying</li>
																					<li>Theme customization</li>
																					<li>Advanced editing capabilities</li>
																					<li>Persistent chat history</li>
																				</ul>
																			</div>
																		</div>
          `;
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
      document.body.appendChild(modal);
    }

    function checkAndStoreApiKey() {
      const storedApiKey = getApiKey();
      if (!storedApiKey) {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `

																		<div class="modal-window">
																			<div class="modal-header">
																				<span class="modal-title">Openrouter API key required!</span>
																			</div>
																			<div class="modal-content">
																				<p>To use PatheticAI, an API key from Openrouter is required. To get this, go to</p>
																				<a href="https://openrouter.ai/settings/keys" target="_blank" style="color: white;">https://openrouter.ai/settings/keys</a>

																					<br>
																						<br>
																							<input type="text" id="apiKeyInput" placeholder="Your API Key Here" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 15px; color: white;">
																								<br>
																									<br>
																										<button id="startupButton" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 15px; color: white; cursor: pointer;">Start up</button>
																									</div>
																								</div>
            `;
        document.body.appendChild(modal);
        document.getElementById('startupButton').addEventListener('click', saveApiKey);
        return false;
      }
      return true;
    }

    function saveApiKey() {
      const apiKey = document.getElementById('apiKeyInput').value.trim();
      if (apiKey && apiKey.startsWith('sk-or-')) {
        localStorage.setItem('openRouterApiKey', apiKey);
        document.querySelector('.modal-overlay').remove();
        showNotification('Booting...');
        setTimeout(() => {
          window.location.reload();
        }, 1000);
      } else {
        showNotification('API key not suitable for PatheticAI...');
      }
    }

    function removeApiKey() {
      localStorage.removeItem('openRouterApiKey');
      disableInput();
      showNotification('API key removed');
    }

    function disableInput() {
      const textarea = document.getElementById('messageInput');
      const sendButton = document.querySelector('.chat-input-container button');
      textarea.disabled = true;
      sendButton.disabled = true;
      textarea.placeholder = 'Please enter API key in settings...';
    }

    function enableInput() {
      const textarea = document.getElementById('messageInput');
      const sendButton = document.querySelector('.chat-input-container button');
      textarea.disabled = false;
      sendButton.disabled = false;
      textarea.placeholder = 'Type your message...';
    }

    function showNotification(message) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    }

    function showWelcomeMessage() {
      const welcomeMessage = "ðŸ‘‹ Welcome to PatheticAI Enhanced! I'm here to help you with any questions or tasks you may have. Feel free to start our conversation!";
      const {
        element
      } = createMessageElement(welcomeMessage, false);
      document.querySelector('.chat-messages').appendChild(element);
    }

    function getApiKey() {
      const apiKey = localStorage.getItem('openRouterApiKey');
      if (apiKey && apiKey.startsWith('sk-or-')) {
        return apiKey;
      }
      return null;
    }

    function initializeUI() {
      console.log("UI Initialized with Theme:", STATE.theme);
      console.log("Current Language:", STATE.currentLanguage);
    }

    function contactEmail() {
      window.open('https://discord.gg/Hb5ccPY3XV', '_blank');
    }

    function setupEventListeners() {}
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registered with scope:', registration.scope);
      })
      .catch(function(error) {
        console.log('Service Worker registration failed:', error);
      });
  }
    </script>
